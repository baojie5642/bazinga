# bazinga

简单的RPC Demo

模仿jupiter @https://github.com/fengjiachun/Jupiter

知识点总结：

1）netty知识点

 在深入netty之前，我觉得至少会用netty，写个hello world版的netty是有必要的，但是学习netty之前，我们至少熟悉java NIO
 
 NIO相比于IO也就是以前的BIO而言，关键的特性就是无阻塞
 
  讲个故事吧：
 
  阻塞IO就是客户端发送请求的时候，需要根据服务端的脸色来看，当服务端有线程空闲的时候才会勉强帮助处理这个请求，就很像我们在工作日请假去银行办理业务，如果银行客服比较空闲的话，会立即给你处理，
  如果此时所有的人都在排队的话，不好意思，你啥也不能坐，坐着吧，看看手机，取号排队吧。
  
 蛋疼的是，假如所有的银行客户都在忙，且忙的业务都很大的话，比如排在你前面那个客服（线程）处理一个亿的定期存款业务，各种复杂的流程，初步一算，前面一个业务操作没有2个小时下不来，好吧，你接着等吧，等着饭点了，银行可不管饭，不好意思，您下次请早，今天服务到此结束了，尼玛，银行拒绝处理，好了，今天排队白搭了，更重要的事就是今天假白请了，工作量也在那阻塞了，完了，一切都完了
 
 这就是阻塞，两端都在阻塞，你在服务端的请求阻塞了，客户端的工作量也阻塞了，这就是阻塞的悲剧
 
 NIO就比较高大上了，故事继续：
 
 晚上加班到11点把白天阻塞的工作量加班干完，到家11点半，洗洗澡，看看零点新闻，说银行业务改革了，大大加快业务处理速度，顿时精神大振，明天去银行接着办理业务，第二天吃了一个煎饼，精神充足的去银行了，发现银行门口等的人很少，感觉有戏，准备去排队，正准备去取排队的序号，一个帅气的黑衣人站在门口柜台的地方热情地问：“这位帅哥，干啥啊？”
 
 屌丝客户：“我来办贷款！”
 
 黑衣人：“那填下单子，贷多少钱，贷多长时间，收入流水账单，收入证明，手机号码，身份证复印件....”
 
 屌丝客户：“好....” 填写中...
 
 1分钟后，写好准备排队...
 
  黑衣人：“你干啥，不用排队，你把填写的资料放在我的柜台上，我等下会帮助你放置在三号柜台的那个美女的案板上，而你可以去上班了，办好了会给你打电话，去上班吧”
 
 屌丝客户：“好....（其实我还想看下那个漂亮的客服妹子呢）”
 
 黑衣人貌似看出屌丝客户的想法，说道：“哦，对了，负责你案子的就是那个三号柜台的那个美女，手机号码是xxxxxxxxx！”
 
 屌丝客户就心满意足地走了......
 
 下午的时候就收到银行的那个美女的电话了：“亲，你的手续办好了，资料已经邮件给你了，你可以查收具体的信息了，如果还有其他的问题，就打这个号码联系我，我还有其他的客户问题要处理，如果问题，欢迎来电！”
 
 好了，这个小故事讲完了，我们来分析一下新的场景对应的NIO模型
 
 角色对应：
 
 客户（N多客户）这些客户就是N多的SocketChannel，n多的客户端请求------>SocketChannel
 
 黑衣人------->selector
 
 
 黑衣人所处的门口柜台-------->ServerSocketChannel
 (ServerSocketChannel.accept()这个方法相当于放置各种请求)
 
 
 三号柜台的美女客户就是服务端的线程，处理各种请求------------>Thread
 
 
 美女客服的手机号码保存在屌丝客户那边（当然客户手机号码也在美女客户那边），那么这个手机号码就是客户端的selector，当服务端处理好请求的时候，就会打电话通知你，屌丝客户一看客服的号码来电了，说明那边处理好了---------美女手机号码======客户端的selector
 
 
 恩，到此为此，NIO的模型基本上已经出来了，你会发现黑衣人的角色很重要，他就像一个接收者，用来负责各种到来的链接，他的职责很简单，就是OP_ACCEPT,而不做任何实际操作
 
 这样做的好处就能体现NIO的牛的地方：两边都做到了解耦，没有了强依赖，没有了阻塞
 
 我们再仔细分析一下，这个黑衣人的所有职责
 1）在门口等待上门的客户（等待连接）
 2）将客户留下来的案例文件送到客服那边去，只要柜台上有文件，他就需要去送到客服那边去
 
 这里面有就两个经典的NIO问题：
 1)selector.open
 2)selector.select
 
 http://zhhphappy.iteye.com/blog/2032893
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 



2）promise设计模式



3）metrics性能测试工具

  提供者端提供请求性能分析报告，使用metrics

  详细介绍查看：

    http://www.cnblogs.com/nexiyi/p/metrics_sample_1.html

    http://www.cnblogs.com/nexiyi/p/metrics_sample_2.html


自测时遇到的坑或者bug

① 异常： Reading from a byte array threw an IOException


原因：序列化传入的对象是A,反序列化要求转换的java对象是B,A序列化的bytes无法匹配B,protostuff中的ProtostuffIOUtil.mergeFrom(bytes, message, schema)方法报错


